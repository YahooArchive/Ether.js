/*
 * Copyright (c) 2013, Yahoo! Inc. All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

window.Ether = window.Ether || { };

(function(){

"use strict";

/**
 * A simple eventing class.  There are some differences between this class an other event classes:
 *
 *   1. It works with normal JavaScript objects and arrays.
 *   2. Handlers are registered in bulk, by registering an object.
 *
 * \#1 has a couple of implications.  I try not to modify objects to enable eventing on them, so
 * you don't normally do `obj.on(...)` to subscribe to events on an object - that would require that
 * `obj` has to somehow acquire an `on()` method.  Instead, you do `Event.on(obj, ...)`.  (I do provide
 * {{#crossLink "Ether.Event/addEvents:method"}}`addEvents()`{{/crossLink}} if you really want to be able to write `obj.on()`
 * and you don't mind having your object modified.)
 *
 * Getting change handlers to work with normal JavaScript objects did require modifying the objects,
 * unfortunately.  Change events are generated by setters on the object.  You can still use the object
 * normally (as long as you don't try to use your own setters.)  See {{#crossLink "Ether.Event/onChange:method"}}`onChange()`{{/crossLink}}
 * for details.
 *
 * \#2 means that you register like this:
 *
 *		Event.on(obj, { evt1: function() { }, evt2: function() { } });
 *
 * instead of like this:
 *
 *		Event.on(obj, "evt1", function() { });
 *		Event.on(obj, "evt2", function() { });
 *
 * This allows faster execution, and simpler, more maintainable registration.
 *
 * @module Infrastructure
 * @namespace Ether
 * @class Event
 * @static
 */

Ether.Event =
{
	on:					on.bind(0, "on", 0),
	once:				on.bind(0, "on", 1),
	off:				off.bind(0, "on"),
	onElement:			onElement,
	offElement:			offElement,
	fire:				fire.bind(0, "on"),
	fireAsync:			fireAsync,
	onChange:			onUpdate.bind(0, "change", 0),
	onChanging:			onUpdate.bind(0, "changing", 0),
	oneChange:			onUpdate.bind(0, "change", 1),
	oneChanging:		onUpdate.bind(0, "changing", 1),
	offChange:			offUpdate.bind(0, "change"),
	offChanging:		offUpdate.bind(0, "changing"),
	onDeepChange:		onDeepChange,
	offDeepChange:		offDeepChange,
	onArrayChanging:	onArray.bind(0, "arrayChanging"),
	offArrayChanging:	offArray.bind(0, "arrayChanging"),
	onArrayChange:		onArray.bind(0, "arrayChanged"),
	offArrayChange:		offArray.bind(0, "arrayChanged"),
	onElementChange:	onElementChange,
	offElementChange:	offElementChange,
	onElementAdding:	onElementAdding,
	onElementRemoved:	onElementRemoved,
	offElementAdding:	offElementAdding,
	offElementRemoved:	offElementRemoved,
	holdEvents:			holdEvents,
	releaseEvents:		releaseEvents,
	addEvents:			addEvents,
	eventsOff:			eventsOff,
	queueHandler:		queueHandler,
	setGetter:			setGetter,
	hasGetter:			hasGetter
};

var timers			= { },
	appMode			= Ether.appMode,
	eventOffCount	= 0,
	arrayMethods	= [ 'push', 'pop', 'reverse', 'shift', 'unshift', 'sort', 'splice' ],
//	exportToDebug	= [ 'on', 'arrayChanging', 'arrayChanged', 'once', 'onChange', 'oneChange' ],
	registry		= Ether.registry(),
	callRegistry	= Ether.registry();

Ether.Debug = Ether.Debug || { };

/*
if (Ether.appMode.debug)
{
	for (i = 0; i < exportToDebug.length; i++)
		registry[exportToDebug[i]] = { objs: [], registered: [] };

	Ether.Debug.initEvent(registry);
}
*/

/**
 * Register a notification object or function for events
 *
 * @method on
 * @param {object} o					The object to register for
 * @param {object|function} [notify]	The notification object or function
 *
 * @example
 *
 * A notification object is used like this:
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { startConversation: function(withWho) { doSomething(withWho); } };
 *
 *		// Request notification when someone fires events on the 'contact' object
 *		Ether.Event.on(contact, notify);
 *
 * `notify.startConversation()` will now be called anytime someone calls
 * `Ether.Event.fire(contact, "startConversation")`.  The handler will receive any
 * additional arguments passed to the call to `fire()`.
 *
 * You can modify the notification object after subscribing with it:
 *
 *		notify.leaveConversation = function(who) { doSomethingElse(who); };
 *		delete notify.startConversation;
 *
 * There's no need to re-subscribe (i.e. you don't need to call `on()` again) when you
 * modify the notification object like this.
 *
 * `notify` is optional.  If it's not provided, the object being registered is used
 * as the notification object:
 *
 *		var intf = { activate: function() { doSomething(); } };
 *
 *		Ether.Event.on(intf);
 *		Ether.Event.fire(intf, 'activate');
 *
 * Now events fired on `intf` will be dispatched to `intf` (as well as other subscribers).
 *
 * A notification function is used like this:
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { startConversation: function(withWho) { doSomething(withWho); };
 *
 *		// Request notification when someone fires events on the 'contact' object
 *		Ether.Event.on(contact, function(event) { doSomething(event); });
 *
 * The first argument to a notification function is the name of the event.  It's followed
 * by the arguments the caller passed to `fire()`.  *This differs from notification objects.*
 * Notification object event handlers do not get the name of the event as their first
 * argument.
 *
 * Fired events do not conflict with data change events.  Modifying data will not call
 * handlers registered with `on()`.
 *
 * A second call to `on()` with the same parameters has no effect, but doing so should
 * be avoided.
 *
 * Use `off()` to unsubscribe.  Since repeated calls to `on()` have no effect, a
 * single call to `off()` unsubscribes no matter how many times you've called `on()`.
 * (This is one reason repeated calls to `on()` should be avoided.)
 *
 * The `o` parameter does not actually have to be an object - you can register for events
 * on anything.  (This is probably something else to avoid.)
 *******************************************************************************/
/**
 * Register a notification object or function for events.  Each method on the notification
 * object will be called at most once.  A notification function will only be called once
 * for each type of event.
 *
 * @method once
 * @param {object} o					The object to register for
 * @param {object|function} [notify]	The notification object or function
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { startConversation: function(withWho) { doSomething(withWho); } };
 *
 *		// Request notification when someone fires events on the 'contact' object
 *		Ether.Event.once(contact, "startConversation", notify);
 *
 * When you use a notification object, there's no need to unsubscribe when you use `once()`.
 * You will be automatially unsubscribed when every method in your notification object has
 * been called once.  You can call `off()` to unsubscribe early, though, if you want.
 *
 * Automatic unsubscription only happens with a notification object.  Functions will not be
 * automatically unsubscribed.
 *
 * As with `on()`, you can modify the notification object after subscribing with it.  It's
 * not a good idea to do this with `once()`.  If all events have already happened once,
 * you will have been unsubscribed and your changes won't have any effect.  If all events
 * but one have happened and you delete that one from the notification object, you won't
 * be unsubscribed.
 *
 * `on()` and `once()` call the same function internally.  A second call to either one
 * with the same parameters has no effect.
 *******************************************************************************/
var dupsReported = 0;

function on(type, once, o, notify)
{
	var registered = registry.get(type, o);
	if (!registered.notify)
	{
		registered.notify	= [];
		registered.once		= [];
	}

	notify = notify || o;

	registered.notify.push(notify);
	registered.once.push(once ? {} : 0);
}

/**
 * Unregister for notifications on an object.
 *
 * @method off
 * @param {object} o					The object to unregister for
 * @param {object|function} [notify]	The notification object or function being unregistered
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { startConversation: function(withWho) { doSomething(withWho); } };
 *
 *		Ether.Event.on(contact, notify);    // Start getting notifications
 *		Ether.Event.off(contact, notify);	// Stop getting notifications
 *
 * Note that you have to pass the exact same arguments to `off()` that were registered
 * with `on()`.
 *******************************************************************************/
function off(type, o, notify)
{
	var j,
		registered = registry.check(type, o);

	if (!registered)
		return;

	notify = notify || o;

	j = registered.notify.indexOf(notify);
	if (j == -1)		// Can't find the notify object so we're done
		return;

	if (trimArray(j, registered.notify, registered.once))
		return;

	// If there are no other registrations on the object, remove it from the object registry
	registry.remove(type, o);

	return 1;
}

/**
 * Register a notification object or function for events on all objects in an array
 *
 * @method onElement
 * @param {array} a						The array to register for
 * @param {object|function} notify		The notification object or function
 *
 * @example
 *
 * This method will call `on()` for all elements in the array.  It will also watch the array
 * for changes and automatically call `on()` on an new elements and `off()` when an element is
 * removed from the array.
 *
 *		var contacts = [ { name: 'Steve', id: 'sfrancisx' }, { name: 'Tammy', id: 'tcaran' } ],
 *			notify	= { startConversation: function(withWho) { doSomething(withWho); } };
 *
 *		// Request notification when someone fires events on any element in `contacts`
 *		Ether.Event.onElement(contacts, notify);
 *
 * `notify.startConversation()` will now be called anytime someone calls
 * `Ether.Event.fire(contacts[i], "startConversation")`.  The `this` pointer will be
 * `contacts[i]`, and the handler will receive any additional arguments passed to the call
 * to `fire()`.
 *
 * Use `offElement()` to unsubscribe.  See {{#crossLink "Ether.Event/on:method"}}`on()`{{/crossLink}} for more information.
 *******************************************************************************/
function onElement(a, notify)
{
	var onElementFuncs = registry.get('onElement', a);

	if (!onElementFuncs.notify)
	{
		onElementFuncs.notify = [ ];
		onElementFuncs.addFuncs = [ ];
		onElementFuncs.removeFuncs = [ ];
	}

	onElementFuncs.notify.push(notify);
	onElementFuncs.addFuncs.push(addFunc);
	onElementFuncs.removeFuncs.push(removeFunc);

	onElementAdding(a, addFunc);
	onElementRemoved(a, removeFunc);

	a.forEach(function(o)
		{
			Ether.Event.on(o, notify);
		});

	function addFunc()
	{
		for (var i = 1; i < arguments.length; i++)
			Ether.Event.on(arguments[i], notify);
	}

	function removeFunc()
	{
		for (var i = 1; i < arguments.length; i++)
			Ether.Event.off(arguments[i], notify);
	}
}

/**
 * Unregister for notifications on all objects in an array.
 *
 * @method offElement
 * @param {array} a						The array to unregister for
 * @param {object|function} [notify]	The notification object or function being unregistered
 *
 * @example
 *
 *		var contacts = [ { name: 'Steve', id: 'sfrancisx' }, { name: 'Tammy', id: 'tcaran' } ],
 *			notify	= { startConversation: function(withWho) { doSomething(withWho); } };
 *
 *		Ether.Event.onElement(contacts, notify);    // Start getting notifications
 *		Ether.Event.offElement(contacts, notify);	// Stop getting notifications
 *******************************************************************************/
function offElement(a, notify)
{
	var idx,
		onElementFuncs = registry.check('onElement', a);

	if (!onElementFuncs)
		return;

	idx = onElementFuncs.notify.indexOf(notify);
	if (idx == -1)
		return;

	offElementAdding(a, onElementFuncs.addFuncs[idx]);
	offElementRemoved(a, onElementFuncs.removeFuncs[idx]);

	onElementFuncs.notify.splice(idx, 1);
	onElementFuncs.addFuncs.splice(idx, 1);
	onElementFuncs.removeFuncs.splice(idx, 1);

	if (!onElementFuncs.notify.length)
		registry.remove('onElement', a);

	a.forEach(function(o)
		{
			Ether.Event.off(o, notify);
		});
}

/**
 * Hold events for an object.
 *
 * @method holdEvents
 * @param {object|array} o			The object or array whose events should be held
 *
 * Queues any event fired on `o` until `releaseEvents()` is called.  Events should
 * only be held for a short time.
 *
 * Every call to `holdEvents()` requires a matching call to `releaseEvents()`.
 *******************************************************************************/
function holdEvents(o)
{
	var holding = registry.get("holding", o);

	if (!holding.events)
	{
		holding.events = [ ];

		holding.holdCount = 0;
	}

	holding.holdCount++;
}

/**
 * Release events for an object.
 *
 * @method releaseEvents
 * @param {object|array} o			The object or array whose events should be released
 *
 * Fires all events held due to a call to `holdEvents()`.  Note that you have to
 * call `releaseEvents()` on an object the same number of times that `holdEvents()`
 * was called before events will be released.
 *******************************************************************************/
function releaseEvents(o)
{
	var args,
		holding = registry.get("holding", o);

	holding.holdCount--;
	if (!holding.holdCount)
	{
		registry.remove("holding", o);

		while (args = holding.events.shift())
			fire.apply(0, args);
	}
}

/**
 * Fire an event on an object.
 *
 * @method fire
 * @param {object} o		The object to fire the event for
 * @param {string} event	The event to fire
 * @param {any} [arg]*		Any additional arguments to pass to the handler
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { startConversation: function(name, contact) { doSomething(contact); } };
 *
 *		Ether.Event.on(contact, notify);    // Start getting notifications
 *		Ether.Event.fire(contact, "startConversation", "Steve", contact);
 *
 * In the example, `fire()` will cause `notify.startConversation()` to be called with
 * two parameters: the string `"Steve"`, and the `contact` object.
 *
 * Fired events do not conflict with data change events.  You can not manually
 * `fire()` an event to an onChange handler.
 *******************************************************************************/
function fire(type, o, event)
{
	// For jshint.
	/* global alert */

	if (eventOffCount)
		return;

	o = getObject(o);

	var registered, j, notifies, once, notify, name, functionArgs,
		removes = [],
		args = Array.prototype.slice.call(arguments, 3),
		holding = registry.check('holding', o);

	// If we're holding events on the object, just save the arguments & return
	if (holding)
	{
		holding.events.push(Array.prototype.slice.call(arguments, 0));
		return;
	}

	registered = registry.check(type, o);
	if (!registered)
		return;

	notifies = registered.notify || [];
	once = registered.once;

	for (j = 0; j < notifies.length; j++)
	{
		if (once[j] && once[j][event])
			continue;

		notify = notifies[j];

		if (typeof notify == 'function')
		{
			functionArgs = functionArgs || Array.prototype.slice.call(arguments, 2);
			try
			{
				notify.apply(o, functionArgs);
			}
			catch (e)
			{
				if (appMode.debug)
					alert('Unhandled exception in event handler: ' + e.toString() + ' at ' + e.stack);

				console.error('Exception in event handler for "' + event + '" on ');
				console.log(o);
				console.log(e);
				console.log(e.stack);
			}

			if (once[j])
				once[j][event] = 1;
		}
		else if (notify && notify[event])
		{
			try
			{
				notify[event].apply(o, args);
			}
			catch (e)
			{
				if (appMode.debug)
					alert('Unhandled exception in event handler: ' + e.toString() + ' at ' + e.stack);

				console.error('Exception in event handler for "' + event + '" on ');
				console.log(o);
				console.log(args);
				console.log(e);
				console.log(e.stack);
			}

			if (once[j])
			{
				once[j][event] = 1;

				removes.push([type, o, notify]);
				for (name in notify)
				{
					if (!once[j][name])
					{
						removes.pop();
						break;
					}
				}
			}
		}
	}

	while (removes.length)
		off.apply(0, removes.pop());
}

/**
 * Asynchronously fire an event on an object.
 *
 * @method fireAsync
 * @param {object} o		The object to fire the event for
 * @param {string} event	The event to fire
 * @param {any} [arg]*		Any additional arguments to pass to the handler
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { startConversation: function(name, contact) { doSomething(contact); } };
 *
 *		Ether.Event.fireAsync(contact, "startConversation", "Steve", contact);
 *		Ether.Event.on(contact, notify);    // Start getting notifications
 *
 * In the example, `fireAsync()` is called before `on()`.  Since the event is fired asynchronously
 * `notify.startConversation()` will still be called - the event won't be fired until after this
 * function returns.
 *******************************************************************************/
function fireAsync()
{
	var args = arguments;
	setTimeout(function() { Ether.Event.fire.apply(0, args); }, 0);
}

/**
 * Register for change notifications on an object
 *
 * @method onChange
 * @param {object} o				The object to register for
 * @param {object|function} notify	The notification object or function
 *
 * @example
 *
 * A notification object is used like this:
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { name: function(oldVal)
 *								{
 *									console.log("Name changed from " + oldVal + " to " + this.name);
 *								}
 *					  };
 *
 *		// Request notification when someone changes values in the 'contact' object.
 *		Ether.Event.onChange(contact, notify);
 *
 * `notify.name()` will now be called anytime someone changes `contact.name`, e.g.:
 *
 *		contact.name = 'Fred';
 *
 * You can register for changes on contained objects:
 *
 *		var contact = { name: { first: 'Steve', last: 'Francis' }, id: 'sfrancisx' },
 *			notify	= { name:
 *						{
 *							first: function(oldVal)
 *							{
 *								console.log("first name changed from " + oldVal + " to " + this.first);
 *							}
 *					  };
 *
 *		Ether.Event.onChange(contact, notify);
 *
 * `notify.name.first()` will now be called when someone changes `contact.first.name`.  This kind of
 * nested notification only works on simple value changes.  So the change event WILL NOT fire if you
 * do this:
 *
 *		contact.name = { first: 'Randy', last: 'Camp' };
 *
 * A notification function is used like this:
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false };
 *
 *		function onchange(oldVal, member, phase) { console.log(member + ' changed to ' + this[member]); };
 *
 *		Ether.Event.onChange(contact, onchange);
 *
 * Note that the handler gets `member` and `phase`.  Since the function is called for changes on all
 * object members, it's necessary to tell the function which member has changed.  (`member` is actually
 * passed to notification object handlers, too, but they shouldn't need it.)
 * `phase` is 'changing' or 'changed'.  'changing' events are fired before the change happens.  I don't
 * think we need both 'before' and 'after' events, so I'm planning to remove 'changing' events.
 *
 * `onChange()` works by installing JavaScript setters on the object.  It will only install setters
 * for members which exist on both the object and the notification object when `onChange()` is
 * called.  For example:
 *
 *		var contact = { name: 'Steve' },
 *			notify	= { id: function() { doSomething(); } };
 *
 *		Ether.Event.onChange(contact, notify);
 *		contact.id = 'sfrancisx';
 *		notify.name = function() { doSomething(); };
 *
 *		contact.name = 'Fred';		// No change event generated - 'name' was not on the
 *									// notification object when 'onChange()' was called.
 *		contact.id = 'fredx';		// No change event generated - 'id' wasn't on 'contact'
 *									// when 'onChange()' was called.
 *
 * So, as with `on()`, you can modify the notification object after subscription, but, as
 * with `once()`, it's not a good idea.  Setters may exist on the object from other calls
 * to `onChange()` on it, so it's not safe to add members to your notification object.
 *
 * Fired events do not conflict with data change events.  Changing data will never call a
 * handler registered with `on()`.
 *
 * A second call to `onChange()` with the same parameters has no effect, but doing so should
 * be avoided.
 *
 * Use `offChange()` to unsubscribe.  Since repeated calls to `onChange()` have no effect, a
 * single call to `offChange()` unsubscribes no matter how many times you've called `onChange()`.
 * (This is why repeated calls to `onChange()` should be avoided.)
 *******************************************************************************/
/**
 * Register for change notifications on an object. Each method on the notification
 * object will be called at most once.  A notification function will only be called once
 * for each member.
 *
 * @method oneChange
 * @param {object} o				The object to register for
 * @param {object|function} notify	The notification object or function
 *
 * @example
 *
 * A notification object is used like this:
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { name: function(oldVal)
 *								{
 *									console.log("Name changed from " + oldVal + " to " + this.name);
 *								}
 *					  }
 *
 *		// Request notification the first time someone changes values in the 'contact' object.
 *		Ether.Event.oneChange(contact, notify);
 *
 * `notify.name()` will now be called the first time someone changes `contact.name`, e.g.:
 *
 *		contact.name = 'Fred';		// Calls the change handler
 *		contact.name = 'Steve';		// Does not call the change handler
 *
 * A notification function is used like this:
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false };
 *
 *		function onchange(oldVal, member, phase) { console.log(member + ' changed to ' + this[member]); };
 *
 *		Ether.Event.oneChange(contact, onchange);
 *
 * See `onChange()` for more details about the parameters passed to the function.
 *
 * As with `once()`, you will be automatically unsubscribed when all change notifications have
 * happened once.
 *
 * The same warnings apply here about changing the notification object: you can do it, but you
 * don't know what the effects will be, so don't do it.  See `once()` and `onChange()` for more
 * details.
 *******************************************************************************/
function onUpdate(update, once, o, notify, fireNow, that, fullName)
{
	// For jshint.
	/* global alert */

	var name, n, v, nested,
		keys = [ ],
		f = notify,
		values = registry.get("values", o);

	// If you pass just a function for 'notify', it will be called for
	// every member change.
	if (typeof notify == "function")
	{
		notify = registry.get("registeredFor", o, notify);
		notify.f = function()
					{
						try
						{
							f.apply(this, arguments);
						}
						catch (e)
						{
							if (appMode.debug)
								alert('Unhandled exception in event handler: ' + e.toString() + ' at ' + e.stack);

							console.error('Exception in event handler function on ');
							console.log(o);
							console.log(e);
							console.log(e.stack);
						}
					};
		notify = notify.f;
		for (name in o)
		{
			// TODO: Dust modifies our objects by adding $idx & $len (at least sometimes)
			// Rendering changes those, which can cause rendering which changes them, etc.
			// This is a hack to avoid that
			if (name.substr(0,1) == '$')
				continue;

			notify[name] = f;
			keys.push(name);
		}
	}
	else
	{
		for (name in notify)
		{
			n = notify[name];
			if (typeof n == 'function')
				keys.push(name);

			// TODO: It's an error for o[name] to change (because we'd have to
			// unsubscribe 'n' recursively and re-subscribe to the new object.)
			// Use onDeepChange() for objects that might have broader changes.
			// NOTE: the operations are done in this order to avoid reading values
			// which have a getter if possible.
			if ((typeof n == 'object') && (v = o[name]) && (typeof v == 'object'))
				onUpdate(update, once, v, n, fireNow, that || o, fullName ? fullName + '.' + name : name);
		}
	}

	if (keys.length)
	{
		if (that)
		{
			nested = registry.get('nestedNotify', that, o, notify);
			nested.fn = onThat;
			on(update, once, o, onThat);
		}
		else
			on(update, once, o, notify);
	}

	keys.forEach(function(name) { setDescriptor(o, name, values, fireNow); });

	function onThat(name, oldVal, phase)
	{
		if (notify[name])
			notify[name].call(that, fullName + '.' + name, oldVal, o, name, phase);
	}
}

//////////////////////////////////////////////////////////////////////////////
function setDescriptor(o, name, values, fireNow)
{
	var readOnly,
		d = Object.getOwnPropertyDescriptor(o, name);

	if (d && !d.set)
	{
		values[name] = o[name];

		d =
		{
			set: function(val)
			{
				readOnly = readOnly || registry.check("readOnly", o);

				if (readOnly && readOnly.ro)
					throw new TypeError("Object is read only");

				// TODO: This won't fire a change event if you set a member to its getter.
				// e.g.
				//		function f() { return 1; }
				//		setGetter(o, 'm', f);
				//		o.m = f;
				// That's a weird thing to do, though...
				var getters = readOnly && readOnly.getters,
					oldVal = (getters && getters[name]) || values[name];

				if (getters)
					getters[name] = 0;

				if (oldVal !== val)
				{
					if (!(oldVal instanceof Date) || !(val instanceof Date)
						|| oldVal.getTime() != val.getTime())
					{
						//fire("changing", o, name, val, "changing");
						values[name] = val;
						fire("change", o, name, oldVal, "change");
					}
				}
			},
			get: function()
			{
				/* jshint -W087:true */	// Allow debugger statement

				readOnly = readOnly || registry.check("readOnly", o);

				var getters = readOnly && readOnly.getters,
					getter = getters && getters[name];

				if (readOnly)
				{
					if (readOnly.breakOnReadAny || (readOnly.breakOnRead && readOnly.breakOnRead[name]))
						debugger;

					if (readOnly.callOnReadAny)
						readOnly.callOnReadAny(name);
					else if (readOnly.callOnRead && readOnly.callOnRead[name])
						readOnly.callOnRead[name](name);
				}

				return getter ? getter.call(this) : values[name];
			}
		};

		Object.defineProperty(o, name, d);
	}

	// TODO: What do I do if there's a getter?
	if (fireNow)
		fire("change", o, name, values[name], "change");
}

// Note: Setting a getter doesn't fire a change event (doing so would
// probably defeat the point of having a getter - anyone watching for
// changes would immediately read the value, causing it to be calculated
// which is probably what you were trying to avoid.)
function setGetter(o, member, getter)
{
	var readOnly = ensureDescriptors(o, member),
		getters = readOnly.getters || { };

	readOnly.getters = getters;
	readOnly.getters[member] = getter;
}

function hasGetter(o, member)
{
	var readOnly = registry.check("readOnly", o);

	return !!(readOnly && readOnly.getters && readOnly.getters[member]);
}

/**
 * Unregister for change notifications on an object.
 *
 * @method offChange
 * @param {object} o				The object to unregister for
 * @param {object|function} notify	The notification object or function being unregistered
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx', online: false },
 *			notify	= { name: function(oldVal) { doSomething(); } };
 *
 *		Ether.Event.onChange(contact, notify);		// Start getting notifications
 *		Ether.Event.offChange(contact, notify);		// Stop getting notifications
 *
 * `offChange()` will un-install the object's setters when the last change handler is
 * removed.
 *******************************************************************************/
function offUpdate(type, o, notify, that, fullName)
{
	var name, values, n, v, wantOff, nested,
		readOnly = registry.check("readOnly", o);

	if (typeof notify == 'function')
	{
		notify = registry.remove("registeredFor", o, notify);
		if (!notify)
			return;
		wantOff = 1;
		notify = notify.f;
	}
	else
	{
		for (name in notify)
		{
			n = notify[name];
			if (typeof n == 'function')
				wantOff = 1;

			// NOTE: the operations are done in this order to avoid reading values
			// which have a getter if possible.
			if ((typeof n == 'object') && (v = o[name]) && (typeof v == 'object'))
				offUpdate(type, v, n, that || o, fullName ? fullName + '.' + name : name);
		}
	}

	if (wantOff)
	{
		if (that)
		{
			nested = registry.remove('nestedNotify', that, o, notify);
			if (nested)
				off(type, o, nested.fn);
		}
		else
			off(type, o, notify);
	}

	if ((readOnly && readOnly.ro) || registry.check("change", o) || registry.check("changing", o))
		return;

	registry.remove("readOnly", o);

	//registry.remove("registeredFor", notify);

	values = registry.check('values', o);

	// TODO: Isn't this an error?
	if (!values)
		return;

	// Undefine setters on the object if there's no longer a reason for them.
	for (name in values)
	{
		Object.defineProperty(o, name, { value: values[name], configurable: true, writable: true });
	}

	registry.remove('values', o);
}

/**
 * Register for change notifications on an object or any of its members, sub-members, etc.
 *
 * @method onDeepChange
 * @param {object} o				The object to register for
 * @param {function} notify			The notification function being registered
 *	@param notify.type				The type of change being reported.  This will be 'change' or the name of
 *									an array mutator method (push, pop, etc.)  The remaining parameters depend
 *									on the type.
 *	@param notify.member			When `type` is 'change' this will be the name of the member which changed
 *	@param notify.oldVal			When `type` is 'change' this will be the previous value of the member
 *	@param notify.retVal			When type is anything except 'change', this will be the 2nd (and final) parameter.
 *									This will be the value returned by the array mutator method.
 *
 * @example
 *
 *		var contact = { user: { name: 'Steve', id: 'sfrancis' }, groups: [ 'Default' ], online: true },
 *			oldUser = contact.user,
 *			notify	= function(type) { doSomething(); };
 *
 *		Ether.Event.onDeepChange(contact, notify);	// Start getting notifications
 *
 *		// This will cause a change notification with this == contact.user
 *		contact.user.name = 'Tammy';
 *
 *		// This will cause a change notification because oldUser == contact.user
 *		oldUser.id = 'tcaran';
 *
 *		// This will cause a change notification with this == contact
 *		contact.user = { name: 'Henri', id: 'henrit' };
 *
 *		// This will cause a change notification with this == contact
 *		contact.online = false;
 *
 *		// This will NOT cause a change notification - oldUser is no longer part of contact.
 *		oldUser.name = 'Steve';
 *
 *		// This will cause a change notification with a type of 'push'
 *		contact.groups.push('Friends');
 *
 *		Ether.Event.offDeepChange(contact, notify);	// Stop getting notifications
 *******************************************************************************/
function onDeepChange(o, notify)
{
	var registered = registry.get('deepchange', o, notify);

	if (registered.oldObjs)
		return;

	registered.oldObjs = [ ];
	objUpdated(o, notify);
}

/**
 * Unregister for deep change notifications on an object
 *
 * @method offDeepChange
 * @param {object} o				The object to unregister for
 * @param {function} notify			The notification function being unregistered
 *
 * @example
 *
 *		var contact = { user: { name: 'Steve', id: 'sfrancis' }, groups: [ 'Default' ], online: true },
 *			oldUser = contact.user,
 *			notify	= function(type) { doSomething(); };
 *
 *		Ether.Event.onDeepChange(contact, notify);		// Start getting notifications
 *
 *		// Do some stuff...
 *
 *		Ether.Event.offDeepChange(contact, notify);		// Stop getting notifications
 *******************************************************************************/
function offDeepChange(o, notify)
{
	objUpdated(o, notify, 1);
	registry.remove('deepchange', o, notify);
}

function objUpdated(o, notify, off)
{
	var registered	= registry.get('deepchange', o, notify),
		newObjs		= [ ],
		oldObjs		= registered.oldObjs,
		updated		= registered.updated || checkObjUpdated,
		repackage	= registered.repackage || repackageArgs;

	registered.repackage = repackage;
	registered.updated = updated;

	registered.oldObjs = newObjs;

	if (!off)
		walk(o, newObjs);

	newObjs.forEach(function(newObj)
		{
			var idx = oldObjs.indexOf(newObj);

			if (idx != -1)
				oldObjs.splice(idx, 1);
			else
			{
				onUpdate('change', 0, newObj, repackage);
				onUpdate('change', 0, newObj, updated);

				if (newObj instanceof Array)
				{
					onArray('arrayChanged', newObj, notify);
					onArray('arrayChanged', newObj, updated);
				}
			}
		});

	// TODO: Multiple deep changes on the same object seems to cause problems with
	// offDeepChange.  I saw this when I was in a conversation under multiple aliases,
	// and I had tabs open for all the aliases and I left the conversation.
	oldObjs && oldObjs.forEach(function(oldObj)
		{
			offUpdate('change', oldObj, repackage);
			offUpdate('change', oldObj, updated);

			if (oldObj instanceof Array)
			{
				offArray('arrayChanged', oldObj, notify);
				offArray('arrayChanged', oldObj, updated);
			}
		});

	function checkObjUpdated(member, oldVal)
	{
		/* jshint validthis: true */

		if ((typeof this[member] == 'object') || (typeof oldVal == 'object'))
			objUpdated(o, notify);
	}

	function repackageArgs(member, obj)
	{
		/* jshint validthis: true */

		notify.call(this, 'change', member, obj);
	}

	function walk(o, objs)
	{
		var name, v;

		if (objs.indexOf(o) != -1)
			return;
		objs.push(o);

		for (name in o)
		{
			v = o[name];
			if (v && (typeof v == 'object'))
				walk(v, objs);
		}
	}
}

/**
 * Register for notification when an item is added to an array
 *
 * @method onElementAdding
 * @param {array} a					The array to unregister for
 * @param {object|function} notify	The notification object or function being registered
 *
 * @example
 *
 *		var contacts = [ { name: 'Steve' }, { name: 'Henri' } ],
 *			notify	 = { adding: function(newItems...) { doSomething(); } };
 *
 *		Ether.Event.onElementAdding(contacts, notify);		// Start getting notifications
 *		contacts.push({ name: 'Fernando' }, { name: 'Tammy' });	// notify.adding() is called with two arguments - Fernando & Tammy.
 *		contacts.splice(0, 1, { name: 'Hung' });				// notify.adding() is called with one argument - Hung.
 *		Ether.Event.offElementAdding(contacts, notify);		// Stop getting notifications
 *
 * The arguments to the notification function are different when you register a function
 * vs registering an object.  When you register a function, the first argument is the name
 * of the event (which will always be 'adding' for elementAdding events.)
 *
 * Array notifications are implemented by overriding methods in Array.prototype.  This
 * means that `a.hasOwnProperty('push')` will return `true`.  The overridden functions
 * are not enumerable, though, so they won't be returned to for...in.
 *
 * 'adding' events are fired before the array is changed.  ('removed' events are fired
 * after the array has changed.)  The assumption is that you're going to do something
 * with the items that are going to be added, instead of doing something different with
 * the array itself.
 *
 * The call to `splice()` in the example will result in both an 'adding' and a
 * 'removed' notification.
 *******************************************************************************/
function onElementAdding(a, notify)
{
	var arrayChangeNotify = registry.get('addingChange', a),
		myNotify =
		{
			push:		addFunc,
			unshift:	addFunc,
			splice:		spliceFunc
		};

	if (!arrayChangeNotify.notify)
	{
		arrayChangeNotify.notify = myNotify;
		arrayChangeNotify.count = 0;

		onArray("arrayChanging", a, myNotify);
	}

	on("adding", 0, a, notify);
	arrayChangeNotify.count++;

	function addFunc()
	{
		/* jshint validthis: true */

		var args = Array.prototype.slice.call(arguments, 0);
		args.unshift("adding", this, "adding");
		fire.apply(0, args);
	}

	function spliceFunc()
	{
		/* jshint validthis: true */

		var args = Array.prototype.slice.call(arguments, 2);
		if (args.length)
		{
			args.unshift("adding", this, "adding");
			fire.apply(0, args);
		}
	}
}

/**
 * Unregister for notification when an item is added to an array
 *
 * @method offElementAdding
 * @param {array} a					The array to unregister for
 * @param {object|function} notify	The notification object or function being registered
 *
 * @example
 *
 *		var contacts = [ { name: 'Steve' }, { name: 'Henri' } ],
 *			notify	 = { adding: function(newItems...) { doSomething(); } };
 *
 *		Ether.Event.onElementAdding(contacts, notify);		// Start getting notifications
 *		contacts.push({ name: 'Fernando' }, { name: 'Tammy' });	// notify.adding() is called with two arguments - Fernando & Tammy.
 *		contacts.splice(0, 1, { name: 'Hung' });				// notify.adding() is called with one argument - Hung.
 *		Ether.Event.offElementAdding(contacts, notify);		// Stop getting notifications
 *
 * Array notifications are implemented by overriding methods in Array.prototype.
 * Unregistering the last array change handler ('changing', 'removed', 'elementChange', etc.)
 * will delete these overrides, allowing the prototype functions to be used again.
 *******************************************************************************/
function offElementAdding(a, notify)
{
	var arrayChangeNotify = registry.check('addingChange', a);

	if (!arrayChangeNotify)
		return;

	off('adding', a, notify);
	arrayChangeNotify.count--;

	if (!arrayChangeNotify.count)
	{
		offArray("arrayChanging", a, arrayChangeNotify.notify);
		registry.remove('addingChange', a);
	}
}

/**
 * Register for notification when an item is added to an array
 *
 * @method onElementRemoved
 * @param {array} a					The array to unregister for
 * @param {object|function} notify	The notification object or function being registered
 *
 * @example
 *
 *		var contacts = [ { name: 'Steve' }, { name: 'Henri' }, { name: 'Fernando' }, { name: 'Tammy' } ],
 *			notify	 = { removed: function(removedItems...) { doSomething(); } };
 *
 *		Ether.Event.onElementRemoved(contacts, notify);		// Start getting notifications
 *		contacts.pop();											// notify.removed() is called with one arguments - Tammy.
 *		contacts.shift();										// notify.removed() is called with one arguments - Steve.
 *		contacts.splice(0, 2, { name: 'Hung' });				// notify.removed() is called with two arguments - Henri & Fernando.
 *		Ether.Event.offElementRemoved(contacts, notify);	// Stop getting notifications
 *
 * The arguments to the notification function are different when you register a function
 * vs registering an object.  When you register a function, the first argument is the name
 * of the event (which will always be 'removed' for elementRemoved events.)
 *
 * Array notifications are implemented by overriding methods in Array.prototype.  This
 * means that `a.hasOwnProperty('push')` will return `true`.  The overridden functions
 * are not enumerable, though, so they won't be returned to for...in.
 *
 * 'removed' events are fired after the array has changed.  ('adding' events are fired
 * before the array is changed.)  The assumption is that you're going to do something
 * with the items that are going to be added, instead of doing something different with
 * the array itself.
 *
 * The call to `splice()` in the example will result in both an 'adding' and a
 * 'removed' notification.
 *******************************************************************************/
function onElementRemoved(a, notify)
{
	var arrayChangeNotify = registry.get("removedChange", a),
		myNotify =
		{
			pop:	removeFunc,
			shift:	removeFunc,
			splice:	spliceFunc
		};

	if (!arrayChangeNotify.notify)
	{
		arrayChangeNotify.notify = myNotify;
		arrayChangeNotify.count = 0;

		onArray("arrayChanged", a, myNotify);
	}

	on("removed", 0, a, notify);
	arrayChangeNotify.count++;

	function removeFunc(el)
	{
		/* jshint validthis: true */

		fire("removed", this, "removed", el);
	}

	function spliceFunc(els)
	{
		/* jshint validthis: true */

		if (els.length)
			fire.apply(0, ["removed", this, "removed"].concat(els));
	}
}

/**
 * Unregister for notification when an item is removed from an array
 *
 * @method offElementRemoved
 * @param {array} a					The array to unregister for
 * @param {object|function} notify	The notification object or function being registered
 *
 * @example
 *
 *		var contacts = [ { name: 'Steve' }, { name: 'Henri' } ],
 *			notify	 = { removed: function(removedItems...) { doSomething(); } };
 *
 *		Ether.Event.onElementRemoved(contacts, notify);		// Start getting notifications
 *		contacts.splice(0, 1, { name: 'Hung' });				// notify.removed() is called with one argument - Steve.
 *		Ether.Event.offElementRemoved(contacts, notify);	// Stop getting notifications
 *
 * Array notifications are implemented by overriding methods in Array.prototype.
 * Unregistering the last array change handler ('changing', 'removed', 'elementChange', etc.)
 * will delete these overrides, allowing the prototype functions to be used again.
 *******************************************************************************/
function offElementRemoved(a, notify)
{
	var arrayChangeNotify = registry.check('removedChange', a);

	if (!arrayChangeNotify)
		return;

	off('removed', a, notify);
	arrayChangeNotify.count--;

	if (!arrayChangeNotify.count)
	{
		offArray("arrayChanged", a, arrayChangeNotify.notify);
		registry.remove('removedChange', a);
	}
}

/**
 * Register for changing notifications on an array.  This event is fired before the
 * array changes.
 *
 * *Events will only be fired by changes made by array mutator methods: `push()`, `pop()`,
 * `reverse()`, `shift()`, `unshift()`, `sort()` and `splice()`.*
 *
 * @method onArrayChanging
 * @param {array} a					The array to register for
 * @param {object|function} notify	The notification object or function being registered
 *
 * @example
 *
 * A notification object is used like this:
 *
 *		var a		= [ 0, 1, 2 ],
 *			notify	= { push: function(pushArgs) { doSomething(); } };
 *
 *		Ether.Event.onArrayChanging(a, notify);		// Start getting notifications
 *
 * A notification function is used like this:
 *
 *		var a		= [ 0, 1, 2 ];
 *
 *		function onArrayChange(method, args) { doSomething(); };
 *
 *		Ether.Event.onArrayChange(a, onArrayChange);	// Start getting notifications
 *
 * The handler is called before the array has been modified.  In both object and function
 * handlers, `this` will be the array.  Handler arguments for an object handler will
 * simply be the arguments passed to the array function.  A handler function gets the name
 * of the method followed by the arguments.  So, for example:
 *
 *		var a		= [ 0, 1, 2 ],
 *			notify	= { push: function(pushArgs) { doSomething(); } };
 *
 *		function onArrayChanging(method, args) { doSomething(); };
 *
 *		Ether.Event.onArrayChanging(a, notify);
 *		Ether.Event.onArrayChanging(a, onArrayChange);
 *
 *		a.push(3);
 *
 * This will call both `notify.push(3)` and `onArrayChange('push', 3)`.
 *
 * Array notifications are implemented by overriding methods in Array.prototype.  This
 * means that `a.hasOwnProperty('push')` will return `true`.  The overridden functions
 * are not enumerable, though, so they won't be returned to for...in.
 *******************************************************************************/
/**
 * Register for changes to an array.  This event is fired after the array changes.
 *
 * *Events will only be fired by changes made by array mutator methods: `push()`, `pop()`,
 * `reverse()`, `shift()`, `unshift()`, `sort()` and `splice()`.*
 *
 * @method onArrayChange
 * @param {array} a					The array to register for
 * @param {object|function} notify	The notification object or function being registered
 *
 * @example
 *
 * A notification object is used like this:
 *
 *		var a		= [ 0, 1, 2 ],
 *			notify	= { push: function(pushArgs) { doSomething(); } };
 *
 *		Ether.Event.onArrayChange(a, notify);		// Start getting notifications
 *
 * A notification function is used like this:
 *
 *		var a		= [ 0, 1, 2 ];
 *
 *		function onArrayChange(method, args) { doSomething(); };
 *
 *		Ether.Event.onArrayChange(a, onArrayChange);	// Start getting notifications
 *
 * The handler is called after the array has been modified.  The notification object handler
 * simply gets the return value of the array function.  A handler function gets the name
 * of the method followed by the return value.  So, for example:
 *
 *		var a		= [ 0, 1, 2 ],
 *			notify	= { push: function(pushArgs) { doSomething(); } };
 *
 *		function onArrayChange(method, args) { doSomething(); };
 *
 *		Ether.Event.onArrayChange(a, notify);
 *		Ether.Event.onArrayChange(a, onArrayChange);
 *
 *		a.push(1);
 *
 * `push()` returns the new length of the array, so this will call both `notify.push(4)` and
 * `onArrayChange('push', 4)`.
 *
 * Array notifications are implemented by overriding methods in Array.prototype.  This
 * means that `a.hasOwnProperty('push')` will return `true`.  The overridden functions
 * are not enumerable, though, so they won't be returned to for...in.
 *******************************************************************************/
function onArray(type, a, notify)
{
	interceptArray(a);
	on(type, 0, a, notify);
}

/**
 * Unregister for changing notifications to an array.
 *
 * @method offArrayChanging
 * @param {array} a					The array to unregister for
 * @param {object|function} notify	The notification object or function being unregistered
 *
 * @example
 *
 *		var a		= [ 0, 1, 2 ],
 *			notify	= { push: function(pushArgs) { doSomething(); } };
 *
 *		Ether.Event.onArrayChanging(a, notify);		// Start getting notifications
 *		Ether.Event.offArrayChanging(a, notify);	// Stop getting notifications
 *
 * Array notifications are implemented by overriding methods in Array.prototype.
 * Unregistering the last handler (both 'changing' and 'change') will delete these
 * overrides, allowing the prototype functions to be used again.
 *******************************************************************************/
/**
 * Unregister for change notifications to an array.
 *
 * @method offArrayChange
 * @param {array} a					The array to unregister for
 * @param {object|function} notify	The notification object or function being unregistered
 *
 * @example
 *
 *		var a		= [ 0, 1, 2 ],
 *			notify	= { push: function(pushArgs) { doSomething(); } };
 *
 *		Ether.Event.onArrayChange(a, notify);		// Start getting notifications
 *		Ether.Event.offArrayChange(a, notify);		// Stop getting notifications
 *
 * Array notifications are implemented by overriding methods in Array.prototype.
 * Unregistering the last handler (both 'changing' and 'change') will delete these
 * overrides, allowing the prototype functions to be used again.
 *******************************************************************************/
function offArray(type, a, notify)
{
	off(type, a, notify);
	uninterceptArray(a);
}

//////////////////////////////////////////////////////////////////////////////
function interceptArray(a)
{
	var i, name, ret, readOnly;

	if (!registry.check('arrayChanging', a) && !registry.check('arrayChanged', a))
	{
		for (i = 0; i < arrayMethods.length; i++)
		{
			name = arrayMethods[i];
			Object.defineProperty(a, name, { value: evtFunc.bind(a, name), configurable: true });
		}
	}

	function evtFunc(name)
	{
		readOnly = readOnly || registry.check('readOnly', a);

		if (readOnly && readOnly.ro)
			throw new TypeError("Object is read only");

		var args = Array.prototype.slice.call(arguments, 0);

		args.unshift("arrayChanging", a);

		fire.apply(0, args);

		ret = Array.prototype[name].apply(a, args.slice(3));

		fire.call(0, "arrayChanged", a, name, ret);

		return ret;
	}
}

//////////////////////////////////////////////////////////////////////////////
function uninterceptArray(a)
{
	var i, name,
		readOnly = registry.check("readOnly", a);

	if ((readOnly && readOnly.ro) || registry.check("arrayChanging", a) || registry.check("arrayChanged", a))
		return;

	for (i = 0; i < arrayMethods.length; i++)
	{
		name = arrayMethods[i];
		delete a[name];
	}
}

/**
 * Register for notification when any element in an array changes
 *
 * @method onElementChange
 * @param {array} a						The array to register for
 * @param {object|function} notify		The notification object or function being registered
 *
 * @example
 *
 *		var contacts = [ { name: 'Steve' }, { name: 'Henri' } ],
 *			notify	 = { name: function(oldVal) { doSomething(); } };
 *
 *		Ether.Event.onElementChange(contacts, notify);
 *
 *		contacts[0].name = 'Scott';		// Calls the notification function with this == contacts[0]
 *										// and oldVal == 'Steve'.
 *		contacts.push({ name: 'Hung' });
 *		contacts[2].name = 'Randy';		// Calls the notification function with this == contacts[2]
 *										// and oldVal == 'Hung'.
 *******************************************************************************/
function onElementChange(a, notify, fireNow)
{
	// TODO: I should be watching the array itself.  Doing this:
	//		user = { name: 'steve' };
	//		 a = [ user ];
	//		onElementChange(a, notify);
	//		a[0] = 0;
	//		user.name = 'tammy';
	// shouldn't result in an onElementChange event.

	var arrayModFuncs = registry.get("elementChange", a);

	if (!arrayModFuncs.notify)
	{
		arrayModFuncs.notify = [ ];
		arrayModFuncs.addFuncs = [ ];
		arrayModFuncs.removeFuncs = [ ];
	}

	arrayModFuncs.notify.push(notify);
	arrayModFuncs.addFuncs.push(addFunc);
	arrayModFuncs.removeFuncs.push(removeFunc);

	onElementAdding(a, addFunc);
	onElementRemoved(a, removeFunc);

	a.forEach(function(o)
		{
			if (typeof o == "object")
				onUpdate("change", 0, o, notify, fireNow);
		});

	function addFunc()
	{
		for (var i = 1; i < arguments.length; i++)
		{
			if (typeof arguments[i] == "object")
				onUpdate("change", 0, arguments[i], notify, fireNow);
		}
	}

	function removeFunc()
	{
		for (var i = 1; i < arguments.length; i++)
		{
			if (typeof arguments[i] == "object")
				offUpdate("change", arguments[i], notify);
		}
	}
}

/**
 * Unregister for notification when any element in an array changes
 *
 * @method offElementChange
 * @param {array} a						The array to register for
 * @param {object|function} notify		The notification object or function being registered
 *
 * @example
 *
 *		var contacts = [ { name: 'Steve' }, { name: 'Henri' } ],
 *			notify	 = { name: function(oldVal) { doSomething(); } };
 *
 *		contacts[0].name = 'Scott';		// Calls the notification function with this == contacts[0]
 *										// and oldVal == 'Steve'.
 *
 *		Ether.Event.onElementChange(contacts, notify);
 *		contacts[0].name = 'Scott';		// Calls the notification function with this == contacts[0]
 *										// and oldVal == 'Steve'.
 *		Ether.Event.offElementChange(contacts, notify);
 *		contacts[0].name = 'Steve';		// Does not call the notification function.
 *******************************************************************************/
function offElementChange(a, notify)
{
	var idx,
		arrayModFuncs = registry.check('elementChange', a);

	if (!arrayModFuncs)
		return;

	idx = arrayModFuncs.notify.indexOf(notify);
	if (idx == -1)
		return;

	offElementAdding(a, arrayModFuncs.addFuncs[idx]);
	offElementRemoved(a, arrayModFuncs.removeFuncs[idx]);

	arrayModFuncs.notify.splice(idx, 1);
	arrayModFuncs.addFuncs.splice(idx, 1);
	arrayModFuncs.removeFuncs.splice(idx, 1);

	if (!arrayModFuncs.notify.length)
		registry.remove('elementChange', a);

	a.forEach(function(o)
		{
			if (typeof o == "object")
				offUpdate("change", o, notify);
		});
}

/**
 * Add event methods to an object
 *
 * @method addEvents
 * @param {object} o			The object to be extended with event methods.
 * @param {object} [which]		The event methods to add to the object
 *
 * By default, the event methods `on()`, `once()`, `off()`, `fire()`, `onChange()`,
 * `oneChange()` and `offChange()` will be added to the object.  Addtionally, if the
 * object is an array, `onArrayChanging()`, `onArrayChange()`, `offArrayChanging()`
 * and `offArrayChange()` will be added.
 *
 * The methods added aren't enumerable so they won't be returned from for..in.
 *
 * @example
 *
 *		contact = { name: "Steve" };
 *
 *		Ether.Event.addEvents(contact);
 *		contact.onChange({ name: function() { doSomething() } });
 *
 * You can restrict the methods that will be added to the object by passing in `which`:
 *
 *		contact = { name: "Steve" };
 *
 *		Ether.Event.addEvents(contact, { on: 1, off: 1, fire: 1 } );
 *******************************************************************************/
function addEvents(o, which)
{
	var name;

	// This could be
	//		which = which || Ether.Event
	// (with an excption for 'addEvents' itself) but the point of 'which' is that I don't want
	// to modify objects in unexpected ways.  If we add a method to the eventing API, it would
	// unexpectedly start appearing on objects which call addEvents().
	if (!which)
	{
		which = { on: 1, once: 1, off: 1, fire: 1, onChange: 1, oneChange: 1, offChange: 1 };

		if (o instanceof Array)
			which.onArrayChanging = which.offArrayChanging = which.onArrayChange = which.offArrayChange = 1;
	}

	// Am I going crazy with Object.defineProperty?  I don't think so.  We expect to use a lot of pure
	// data objects.  Make sure that adding events to them doesn't break for..in loops that don't
	// expect these methods.
	for (name in which)
		Object.defineProperty(o, name, { value: Ether.Event[name].bind(0, o), configurable: true });
}

//////////////////////////////////////////////////////////////////////////////
function eventsOff(off)
{
	if (off)
		eventOffCount++;
	else
		eventOffCount--;
}

//////////////////////////////////////////////////////////////////////////////
function queueHandler(fn, delay /*, arg1, arg2...*/)
{
	var o, callFn, fnsAt, fn2,
		args = Array.prototype.slice.call(arguments, 2);

	args.unshift(fn);
	o = callRegistry.get.apply(0, args);

	delay = delay || 10;

	if (!o.queued)
	{
		o.queued = 1;

		callFn = function()
			{
				callRegistry.remove.apply(0, args);
				args.shift();
				fn.apply(0, args);
			};

		fnsAt = timers[delay] = timers[delay] || [ ];
		fnsAt.push(callFn);

		if (fnsAt.length == 1)
		{
			setTimeout(
				function()
				{
					while (fn2 = fnsAt.shift())
						fn2();
				}, delay);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////
//function queueHandler2(fn, delay /*, arg1, arg2...*/)
/*{
	var o,
		args = Array.prototype.slice.call(arguments, 2);

	args.unshift(fn);
	o = callRegistry.get.apply(0, args);

	delay = delay || 0;

	if (!o.queued)
	{
		o.queued = 1;
		setTimeout(function()
			{
				callRegistry.remove.apply(0, args);
				args.shift();
				fn.apply(0, args);
			}, delay);
	}
}*/

/**
 * Register for changing notifications on an object (fired before the change occurs.)
 *
 * @method onChanging
 * @deprecated Tell Steve if you need it.
 * @param {object} o				The object to register for
 * @param {object|function} notify	The notification object or function
 *******************************************************************************/
/**
 * Register for a single changing notification on an object (fired before the change occurs.)
 *
 * @method oneChanging
 * @deprecated Tell Steve if you need it.
 * @param {object} o				The object to register for
 * @param {object|function} notify	The notification object or function
 *******************************************************************************/
/**
 * Unregister for changing events on an object (fired before the change occurs.)
 *
 * @method offChanging
 * @deprecated Tell Steve if you need it.
 * @param {object} o				The object to register for
 * @param {object|function} notify	The notification object or function
 *******************************************************************************/

 /**
 * @class Debug
 * @static
 *******************************************************************************/
/**
 * Make an object read-only.  Attempting to modify a read-only object will throw a
 * TypeError.
 *
 * @method readOnly
 * @param {object} o			The object to make read-only
 * @return {object}				An object which can be used to make the object read-write. (You can also
 *								just call `readWrite()` on the object.)
 *
 * @example
 *
 *		contact = { name: "Steve", yid: "sfrancis", network: { id: "yahoo" } };
 *		contacts = [ contact ];
 *
 *		Ether.Debug.readOnly(contacts);
 *
 *		contacts.push({ name: "Henri" });	// Throws a TypeError
 *		contacts[0] = { name: "Scott" };	// Throws a TypeError
 *		contacts[1] = { name: "Tammy" };	// Succeeds, incorrectly.  DON'T DO THIS!!!
 *
 *		Ether.Debug.readOnly(contact);
 *
 *		contact.lastName	= "Francis";	// Throws a TypeError
 *		contact.name		= "Henri";		// Throws a TypeError
 *		delete contact.name;				// Throws a TypeError
 *		contact.network.id	= "msn";		// Succeeds - contact.network is not read-only.
 *
 *
 * **Notes:**
 *
 * When you make a non-Array object read-only, it gets sealed against further changes,
 * and members can no longer be added or removed.  You can use `readWrite()` to make
 * the object read-write again, allowing you to change the values of members.  However,
 * sealing can't be undone, so calling `readWrite()` won't allow you to add or delete
 * members from the object.
 *
 * Arrays are not sealed when you make them read-only.  This is so we'll be able to
 * add new elements to the array (after making it read-write).
 *
 * Note also that making an array read-only *does not* make objects in the array
 * read-only.  The array itself becomes read-only.  Use `readOnlyArray()` to make
 * objects in the array read-only also.
 *******************************************************************************/
Ether.Debug.readOnly = function readOnly(o)
{
	var name,
		values = registry.get("values", o),
		isReadOnly = registry.get("readOnly", o);

	isReadOnly.ro = 1;

	for (name in o)
		setDescriptor(o, name, values);

	if (o instanceof Array)
		interceptArray(o);
	else
		Object.seal(o);

	return isReadOnly;
};

/**
 * Make an array and its members read-only.  Attempting to modify a read-only object will throw a
 * TypeError.
 *
 * @method readOnlyArray
 * @param {array} a			The array to make read-only
 *
 * @example
 *
 *		contact = { name: "Steve", yid: "sfrancis", network: { id: "yahoo" } };
 *		contacts = [ contact ];
 *
 *		Ether.Debug.readOnlyArray(contacts);
 *
 *		contacts.push({ name: "Henri" });	// Throws a TypeError
 *		contacts[0] = { name: "Scott" };	// Throws a TypeError
 *		contacts[1] = { name: "Tammy" };	// Succeeds, incorrectly.  DON'T DO THIS!!!
 *
 *		contact.lastName	= "Francis";	// Throws a TypeError
 *		contact.name		= "Henri";		// Throws a TypeError
 *		delete contact.name;				// Throws a TypeError
 *		contact.network.id	= "msn";		// Succeeds - contact.network is not read-only.
 *
 *
 * **Notes:**
 *
 * This is a convenience method.  It simply calls `readOnly()` on the array and on all its members.
 *
 * The implementation actually uses for..in to iterate over the array.  This means the method can
 * be used on an object also, to make a single level of contained objects read-only.
 *******************************************************************************/
Ether.Debug.readOnlyArray = function readOnlyArray(a)
{
	var name,
		mdr = Ether.Debug.readOnly;

	mdr(a);
	for (name in a)
		mdr(a[name]);
};

/**
 * Make an object read-write.
 *
 * @method readWrite
 * @param {object} o			The object to make read-only
 *
 * @example
 *
 *		contact = { name: "Steve", yid: "sfrancis", network: { id: "yahoo" } };
 *		contacts = [ contact ];
 *
 *		Ether.Debug.readOnly(contacts);
 *		Ether.Debug.readOnly(contact);
 *
 *		contacts.push({ name: "Henri" });	// Throws a TypeError
 *		contact.lastName = "Francis";		// Throws a TypeError
 *
 *		Ether.Debug.readWrite(contact);
 *		contact.name		= "Henri";		// Succeeds
 *		contact.lastName	= "Francis";	// Throws a TypeError - the object is still sealed
 *		contacts.push({ name: "Henri" });	// Throws a TypeError - the array is still read-only
 *		contacts[0] = { name: "Hung" };		// Throws a TypeError - the array is still read-only
 *
 *		Ether.Debug.readWrite(contacts);
 *		contacts.push({ name: "Henri" });	// Succeeds
 *		contacts[0] = { name: "Hung" };		// Succeeds
 *
 *
 * **Notes:**
 *
 * When you make a non-Array object read-only, it gets sealed against further changes,
 * and members can no longer be added or removed.  You can use `readWrite()` to make
 * the object read-write again, allowing you to change the values of members.  However,
 * sealing can't be undone, so calling `readWrite()` won't allow you to add or delete
 * members from the object.
 *
 * Arrays are not sealed when you make them read-only.  This is so we'll be able to
 * add new elements to the array (after making it read-write).
 *
 * Note also that making an array read-write *does not* make objects in the array
 * read-write.  Use `readWriteArray()` to make objects in the array read-write also.
 *******************************************************************************/
Ether.Debug.readWrite = function readWrite(o)
{
	var readOnly = registry.check("readOnly", o);

	if (readOnly)
		readOnly.ro = 0;
};

/**
 * Make an array and its members read-write.
 *
 * @method readWriteArray
 * @param {array} a			The array to make read-write
 *
 * @example
 *
 *		contact = { name: "Steve", yid: "sfrancis", network: { id: "yahoo" } };
 *		contacts = [ contact ];
 *
 *		Ether.Debug.readOnlyArray(contacts);
 *
 *		contacts.push({ name: "Henri" });	// Throws a TypeError
 *		contacts[0].name = "Scott";			// Throws a TypeError
 *
 *		Ether.Debug.readWriteArray(contacts);
 *
 *		contact.lastName	= "Francis";	// Throws a TypeError - the object is still sealed
 *		contact.name		= "Henri";		// Succeeds
 *		delete contact.name;				// Throws a TypeError - the object is still sealed
 *		contacts.push({ name: "Hung"; });	// Succeeds
 *		contacts[1].lastName = "Nguyen";	// Succeeds - the object was never read-only,
 *											// so it wasn't sealed.
 *
 *
 * **Notes:**
 *
 * This is a convenience method.  It simply calls `readWrite()` on the array and on all its members.
 *
 * The implementation actually uses for..in to iterate over the array.  This means the method can
 * be used on an object also, to make a single level of contained objects read-write.
 *******************************************************************************/
Ether.Debug.readWriteArray = function readWriteArray(a)
{
	var name,
		mdr = Ether.Debug.readWrite;

	mdr(a);
	for (name in a)
		mdr(a[name]);
};

/**
 * Break when an object changes, or when a specific member of an object changes
 *
 * @method breakOnChange
 * @param {object} o			The object
 * @param {string} [member]		The name of the member
 *
 * @example
 *
 *		var contact = { name: 'Steve' };
 *
 *		Ether.Debug.breakOnChange(contact, 'name');		// Break any time contact.name changes
 *
 *******************************************************************************/
Ether.Debug.breakOnChange = function(o, member)
{
	var f = function() { /* jshint -W087:true */ debugger; },
		n = f;

	if (member)
	{
		n = { };
		n[member] = f;
	}
		
	onUpdate('change', 0, o, n);
};

/**
 * Write a log message when an object changes, or when a specific member of an object changes
 *
 * @method logOnChange
 * @param {object} o			The object
 * @param {string} [member]		The name of the member
 *
 * @example
 *
 *		var contact = { name: 'Steve' };
 *
 *		Ether.Debug.logOnChange(contact, 'name');		// Write a log message any time contact.name changes
 *
 * **Notes:**
 * Chrome only includes a call stack for `console.error()`, so that's what I use.
 *******************************************************************************/
Ether.Debug.logOnChange = function(o, member)
{
	var n;

	if (member)
	{
		n = { };
		n[member] = function(oldVal)
					{
						/* jshint validthis: true */

						console.error(member + ' changed from ' + oldVal + ' to ' + this[member]);
					};
	}
	else
	{
		n = function(member, oldVal)
			{
				/* jshint validthis: true */

				console.error(member + ' changed from ' + oldVal + ' to ' + this[member]);
			};
	}

	onUpdate('change', 0, o, n);
};

/**
 * Break when a condition evaluates to truthy
 *
 * @method breakWhen
 * @param {object} o			The object
 * @param {function} condition	The function to evaluate on changes
 * @param {string} [member]		Only check when `member` changes
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx' };
 *
 *      // Break if `name` is set to the same value as `id`, or if `id` is set to the
 *      // same value as `name`
 *		Ether.Debug.breakWhen(contact, 
 *                                  function(member, newVal, oldVal)
 *                                  {
 *                                      return this.name == this.id;
 *                                  });
 *
 *      // Break if `name` is set to the same value as `id`.  This is only called
 *      // when `name` changes, so it won't break if `id` is changed to the same
 *      // value as `name`.
 *		Ether.Debug.breakWhen(contact, 
 *                                  function(member, newVal, oldVal)
 *                                  {
 *                                      return this.name == this.id;
 *                                  }, 'name');
 *
 *******************************************************************************/
Ether.Debug.breakWhen = function(o, condition, member)
{
	var n = { };
	
	if (member)
	{
		n[member] = function(oldVal)
					{
						/* jshint -W087:true */	// Allow debugger statement
						if (condition.call(this, this[member], oldVal))
							debugger;
					};
		
	}
	else
	{
		n = function(member, oldVal)
			{
				/* jshint -W087:true */	// Allow debugger statement
				if (condition.call(this, member, this[member], oldVal))
					debugger;
			};
	}
	
	onUpdate('change', 0, o, n);
};

/**
 * Break when a member is set to a certain value
 *
 * @method breakWhenEquals
 * @param {object} o			The object
 * @param {string} member		The member to compare
 * @param {any} value			The value to compare to
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx' };
 *
 *      // Break if `contact.name` is set to 'Steven'
 *		Ether.Debug.breakWhenEquals(contact, 'name', 'Steven');
 *
 *******************************************************************************/
Ether.Debug.breakWhenEquals = function(o, member, value)
{
	var n = { };

	n[member] = function()
				{
					/* jshint -W087:true */	// Allow debugger statement

					if (this[member] === value)
						debugger;
				};

	onUpdate('change', 0, o, n);
};

/**
 * Break when a member is set to a value which is inside a given set
 *
 * @method breakWhenIn
 * @param {object} o			The object
 * @param {string} member		The member to compare
 * @param {any} valuesOrMin		If this is an array, the value should be in the array
 *                              and `max` is ignored.  Otherwise this is the minimum bound
 *                              of the value.
 * @param {any} [max]			The maximum bound for the value.  Only used if `valuesOrMin` is
 *                              not an array
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx' };
 *
 *      // Break if `contact.name` is set to a lowercase string
 *		Ether.Debug.breakWhenIn(contact, 'name', 'a', 'z');
 *
 *      // Break if `contact.name` is set to a horrible nickname
 *		Ether.Debug.breakWhenIn(contact, 'name', [ 'Stevie', 'Stevaroo', 'Steveareenie' ]);
 *
 *******************************************************************************/
Ether.Debug.breakWhenIn = function(o, member, valuesOrMin, max)
{
	var n = { };

	n[member] = function()
				{
					/* jshint -W087:true */	// Allow debugger statement

					if (valuesOrMin instanceof Array)
					{
						if (valuesOrMin.indexOf(this[member]) != -1)
							debugger;
					}
					else
					{
						if (this[member] >= valuesOrMin && this[member] <= max)
							debugger;
					}
				};

	onUpdate('change', 0, o, n);
};

/**
 * Break when a member is set to a value which is not inside a given set
 *
 * @method breakWhenNotIn
 * @param {object} o			The object
 * @param {string} member		The member to compare
 * @param {any} valuesOrMin		If this is an array, the value should not be in the array
 *                              and `max` is ignored.  Otherwise this is the minimum bound
 *                              of the value.
 * @param {any} [max]			The maximum bound for the value.  Only used if `valuesOrMin` is
 *                              not an array
 *
 * @example
 *
 *		var contact = { name: 'Steve', id: 'sfrancisx' };
 *
 *      // Break if `contact.name` is not set to a lowercase string
 *		Ether.Debug.breakWhenNotIn(contact, 'name', 'a', 'z');
 *
 *      // Break if `contact.name` is not set to a horrible nickname
 *		Ether.Debug.breakWhenNotIn(contact, 'name', [ 'Stevie', 'Stevaroo', 'Steveareenie' ]);
 *
 *******************************************************************************/
Ether.Debug.breakWhenNotIn = function(o, member, valuesOrMin, max)
{
	var n = { };

	n[member] = function()
				{
					/* jshint -W087:true */	// Allow debugger statement

					if (valuesOrMin instanceof Array)
					{
						if (valuesOrMin.indexOf(this[member]) == -1)
							debugger;
					}
					else
					{
						if (this[member] < valuesOrMin || this[member] > max)
							debugger;
					}
				};

	onUpdate('change', 0, o, n);
};

/**
 * Break when an object is accessed, or when a specific member of an object is accessed.
 *
 * @method breakOnRead
 * @param {object} o			The object
 * @param {string} [member]		The name of the member
 *
 * @example
 *
 *		var contact = { name: 'Steve' };
 *
 *		Ether.Debug.breakOnRead(contact, 'name');		// Break any time contact.name is referenced
 *
 *******************************************************************************/
/**
 * Stop breaking when an object is accessed, or when a specific member of an object is accessed.
 *
 * @method noBreakOnRead
 * @param {object} o			The object
 * @param {string} [member]		The name of the member
 *
 * @example
 *
 *		var contact = { name: 'Steve' };
 *
 *		Ether.Debug.noBreakOnRead(contact, 'name');		// Stop breaking any time contact.name is referenced
 *
 *******************************************************************************/
Ether.Debug.breakOnRead = function(o, member) { breakOnRead(o, member, 1); };
Ether.Debug.noBreakOnRead = function(o, member) { breakOnRead(o, member, 0); };

function breakOnRead(o, member, doBreak)
{
	var readOnly = ensureDescriptors(o);

	if (member)
	{
		readOnly.breakOnRead = readOnly.breakOnRead || { };
		readOnly.breakOnRead[member] = doBreak;
	}
	else
		readOnly.breakOnReadAny = doBreak;
}

/**
 * Write a log message when an object is accessed, or when a specific member of an object is accessed.
 *
 * @method logOnRead
 * @param {object} o			The object
 * @param {string} [member]		The name of the member
 *
 * @example
 *
 *		var contact = { name: 'Steve' };
 *
 *		Ether.Debug.logOnRead(contact, 'name');		// Write a log message any time contact.name is referenced
 *
 * **Notes:**
 * Chrome only includes a call stack for `console.error()`, so that's what I use.
 *******************************************************************************/
Ether.Debug.logOnRead = function(o, member)
{
	var readOnly = ensureDescriptors(o),
		f = function(member)
			{
				console.error('Read ' + member);
			};

	if (member)
	{
		readOnly.callOnRead = readOnly.callOnRead || { };
		readOnly.callOnRead[member] = f;
	}
	else
		readOnly.callOnReadAny = f;
};

function ensureDescriptors(o, name)
{
	var values = registry.get("values", o),
		readOnly = registry.get("readOnly", o);

	if (name)
		setDescriptor(o, name, values);
	else
	{
		for (name in o)
			setDescriptor(o, name, values);
	}

	return readOnly;
}

function getObject(name, o)
{
	if (typeof name != 'string')
		return name;

	o = o || window;

	name = name.split('.');

	while (o && name.length)
		o = o[name.shift()];

	return o;
}

function trimArray(idx, a1, a2)
{
	if (a1)
	{
		a1[idx] = 0;

		idx = a1.length;
		while (idx && !a1[idx-1])
		{
			a1.pop();
			a2 && a2.pop();
			idx--;
		}

		return idx;
	}
}

})();
